package filesystem

import (
	"io"
	os "os"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/s3"
	mock "github.com/stretchr/testify/mock"
)

// MockCoreFs is an autogenerated mock type for the CoreFs type
type MockCoreFs struct {
	mock.Mock
}

func (_m *MockCoreFs) MkdirAll(path string, perm os.FileMode) error {
	ret := _m.Called(path, perm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, os.FileMode) error); ok {
		r0 = rf(path, perm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Create provides a mock function with given fields: name
func (_m *MockCoreFs) Create(name string) (file, error) {
	ret := _m.Called(name)

	var r0 file
	if rf, ok := ret.Get(0).(func(string) file); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(file)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Open provides a mock function with given fields: name
func (_m *MockCoreFs) Open(name string) (file, error) {
	ret := _m.Called(name)

	var r0 file
	if rf, ok := ret.Get(0).(func(string) file); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(file)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Copy provides a mock function with given fields: dst, src
func (_m *MockCoreFs) Copy(dst io.Writer, src io.Reader) (int64, error) {
	ret := _m.Called(dst, src)

	var r0 int64
	if rf, ok := ret.Get(0).(func(io.Writer, io.Reader) int64); ok {
		r0 = rf(dst, src)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(io.Writer, io.Reader) error); ok {
		r1 = rf(dst, src)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stat provides a mock function with given fields: name
func (_m *MockCoreFs) Stat(name string) (os.FileInfo, error) {
	ret := _m.Called(name)

	var r0 os.FileInfo
	if rf, ok := ret.Get(0).(func(string) os.FileInfo); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(os.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// file is an autogenerated mock type for the file type
type MockFile struct {
	mock.Mock
}

func (_m *MockFile) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *MockFile) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Read provides a mock function with given fields: p
func (_m *MockFile) Read(p []byte) (int, error) {
	ret := _m.Called(p)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadAt provides a mock function with given fields: p, off
func (_m *MockFile) ReadAt(p []byte, off int64) (int, error) {
	ret := _m.Called(p, off)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte, int64) int); ok {
		r0 = rf(p, off)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, int64) error); ok {
		r1 = rf(p, off)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Seek provides a mock function with given fields: offset, whence
func (_m *MockFile) Seek(offset int64, whence int) (int64, error) {
	ret := _m.Called(offset, whence)

	var r0 int64
	if rf, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = rf(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = rf(offset, whence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stat provides a mock function with given fields:
func (_m *MockFile) Stat() (os.FileInfo, error) {
	ret := _m.Called()

	var r0 os.FileInfo
	if rf, ok := ret.Get(0).(func() os.FileInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(os.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Write provides a mock function with given fields: p
func (_m *MockFile) Write(p []byte) (int, error) {
	ret := _m.Called(p)

	var r0 int
	if rf, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = rf(p)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockFileSystem is an autogenerated mock type for the FileSystem type
type MockFileSystem struct {
	mock.Mock
}

func NewMockFilesystem() *MockFileSystem {
	return &MockFileSystem{}
}

// Get provides a mock function with given fields: path
func (_m *MockFileSystem) Get(path string) (file, error) {
	ret := _m.Called(path)

	var r0 file
	if rf, ok := ret.Get(0).(func(string) file); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(file)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Put provides a mock function with given fields: src, location, fileType
func (_m *MockFileSystem) Put(src io.ReadSeeker, path string, extension string) (file, error) {
	ret := _m.Called(src, path, extension)

	var r0 file
	if rf, ok := ret.Get(0).(func(io.ReadSeeker, string, string) file); ok {
		r0 = rf(src, path, extension)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(file)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(io.ReadSeeker, string, string) error); ok {
		r1 = rf(src, path, extension)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileInfo is an autogenerated mock type for the FileInfo type
type MockFileInfo struct {
	mock.Mock
}

// IsDir provides a mock function with given fields:
func (_m *MockFileInfo) IsDir() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ModTime provides a mock function with given fields:
func (_m *MockFileInfo) ModTime() time.Time {
	ret := _m.Called()

	var r0 time.Time
	if rf, ok := ret.Get(0).(func() time.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	return r0
}

// Mode provides a mock function with given fields:
func (_m *MockFileInfo) Mode() os.FileMode {
	ret := _m.Called()

	var r0 os.FileMode
	if rf, ok := ret.Get(0).(func() os.FileMode); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(os.FileMode)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *MockFileInfo) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Size provides a mock function with given fields:
func (_m *MockFileInfo) Size() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// Sys provides a mock function with given fields:
func (_m *MockFileInfo) Sys() interface{} {
	ret := _m.Called()

	var r0 interface{}
	if rf, ok := ret.Get(0).(func() interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// S3Caller is an autogenerated mock type for the S3Caller type
type MockS3Caller struct {
	mock.Mock
}

// GetObject provides a mock function with given fields: input
func (_m *MockS3Caller) GetObject(input *s3.GetObjectInput) (*s3.GetObjectOutput, error) {
	ret := _m.Called(input)

	var r0 *s3.GetObjectOutput
	if rf, ok := ret.Get(0).(func(*s3.GetObjectInput) *s3.GetObjectOutput); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*s3.GetObjectInput) error); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewSvc provides a mock function with given fields: cfgs
func (_m *MockS3Caller) NewSvc(cfgs ...*aws.Config) S3Caller {
	ret := _m.Called(cfgs)

	var r0 S3Caller
	if rf, ok := ret.Get(0).(func(...*aws.Config) S3Caller); ok {
		r0 = rf(cfgs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(S3Caller)
		}
	}

	return r0
}

// PutObject provides a mock function with given fields: input
func (_m *MockS3Caller) PutObject(input *s3.PutObjectInput) (*s3.PutObjectOutput, error) {
	ret := _m.Called(input)

	var r0 *s3.PutObjectOutput
	if rf, ok := ret.Get(0).(func(*s3.PutObjectInput) *s3.PutObjectOutput); ok {
		r0 = rf(input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*s3.PutObjectInput) error); ok {
		r1 = rf(input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
